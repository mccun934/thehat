#!/usr/bin/ruby
###########################################################################
# This file is part of TheHat - an interactive workflow system
# Copyright (C) 2008  David Parker
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
###########################################################################

require 'wfappframe'
require 'thread'
require 'rubygems'
require 'IRC'
require 'IRCEvent-patch'


class IRCFrontend < HatApp

	def initialize
		super
		getConfig('thehat-irc',[:nic,:server,:port,:name,:channel])
		@config[:channel] = "##{@config[:channel]}"
	end	
	


	def run	
		logmessage(:com,"connecting to #{configValue(:server)} on port #{configValue(:port)} as #{configValue(:nic)}")
		
		ircSession = IRC.new(configValue(:nic), configValue(:server), configValue(:port), configValue(:name))
		IRCEvent.add_callback('endofmotd') { |event| 
			ircSession.add_channel(configValue(:channel))
			logmessage(:com,"connected")
		}
			
		
		IRCEvent.add_callback('join') { |event|
			logmessage(:app,"joined #{configValue(:channel)}, saying hello")
			drainMessages(:app) { |line|
				ircSession.send_message(event.channel, line)
			}
			logmessage(:app,"listening for commands")
			Thread.new {
				logmessage(:clock,"starting clock thread")
				while true
					@mutex.synchronize do
						begin
							@workflow.ticToc(false) # if true, it's quite noisy
							drainMessages(:clock) { |line|
								ircSession.send_message(event.channel, line)
							}
						rescue
							logmessage(:error,$!)
							ircSession.send_message(event.channel,$!)
						end
					end
					sleep(5)
				end
			}
		}
		
		IRCEvent.add_callback('privmsg') { |event|
			logmessage(:user,"#{event.channel} #{event.from}: '#{event.message}'")
			if event.channel =~ /^#{configValue(:nic)}/
				logmessage(:heard,"/msg from #{event.from} - saying sorry")
				ircSession.send_message(event.from,"Outside of a group I am useless - sorry.")
			else
				if event.message =~ /^#{configValue(:nic)}[: ,]+(.*)/ or event.message =~ /^#{configValue(:nic)}$/
					begin
						@mutex.synchronize do
							if cmd = $1
								if cmd =~ /^quit$|^shutdown$/
									IRCConnection.quit
								else
									@workflow.processCommand(event.from,cmd)
								end
							else
								@workflow.processCommand(event.from,'')
							end
							drainMessages(:cmd) { |line|
								ircSession.send_message(event.channel, line)
							}
						end
					rescue
						logmessage(:error,$!)
						ircSession.send_message(event.channel,$!)
					end
				end
			end
		}
		ircSession.connect
		logmessage(:app,"shutdown")
	end
end

IRCFrontend.new.run