#!/usr/bin/ruby
###########################################################################
# This file is part of TheHat - an interactive workflow system
# Copyright (C) 2008  David Parker
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
###########################################################################

require 'wfengine'
require 'thread'
require 'rubygems'
require 'IRC'

iniFilename = ARGV[0]
workflow = ARGV[1]

if not iniFilename
	puts "You must specify a configuration file - ending run\n"
	exit(1)
end

ini = IniFile.load(iniFilename)

nic = ini['thehat-irc']['nic']
server = ini['thehat-irc']['server']
port = ini['thehat-irc']['port']
name = ini['thehat-irc']['name']
nic = ini['thehat-irc']['nic']
channel = "##{ini['thehat-irc']['channel']}"


workflow = Workflow.new(iniFilename,workflow)
#workflow.whatsGoingOn('STARTUP')

puts "** #{Time.now.localtime.to_s} connecting to #{server} on port #{port} as #{nic}\n"

ircSession = IRC.new(nic, server, port, name)
IRCEvent.add_callback('endofmotd') { |event| 
	ircSession.add_channel(channel)
	puts "** #{Time.now.localtime.to_s} connected\n"
}


mutex = Mutex.new # The engine isn't thread safe, so the clock thread and the irc thread sync through this


IRCEvent.add_callback('join') { |event|
	puts "** #{Time.now.localtime.to_s} joined #{channel}, saying hello\n"
	workflow.messages.split(/\n/).each { |line|
		ircSession.send_message(event.channel, line)
	}
	workflow.clearMessages
	puts "** #{Time.now.localtime.to_s} listening for commands\n"
	Thread.new {
		puts "@@ #{Time.now.localtime.to_s} starting clock thread\n"
		while true
			mutex.synchronize do
				begin
					workflow.ticToc(false) # if true, it's quite noisy
					workflow.messages.split(/\n/).each { |line|
						ircSession.send_message(event.channel, line)
						puts "@@ #{Time.now.localtime.to_s} #{line}\n"
						sleep(0.5)
					}
					workflow.clearMessages
				rescue
					puts "!! #{Time.now.localtime.to_s} #{$!}\n"
					ircSession.send_message(event.channel,$!)
				end
			end
			sleep(5)
		end
	}
}

IRCEvent.add_callback('privmsg') { |event|
	puts "++ #{Time.now.localtime.to_s} #{event.from}: '#{event.message}'\n"
	if event.channel =~ /#{nic}/
		ircSession.send_message(event.from,"Outside of a group I am useless - sorry.")
	else
		if event.message =~ /^#{nic} (.*)/ or event.message =~ /^#{nic}$/
			begin
				mutex.synchronize do
					if cmd = $1
						if cmd =~ /^quit$|^shutdown$/
							IRCConnection.quit
						else
							workflow.processCommand(event.from,cmd)
						end
					else
						workflow.processCommand(event.from,'')
					end
					workflow.messages.split(/\n/).each { |line|
						ircSession.send_message(event.channel, line)
						puts "== #{Time.now.localtime.to_s} #{line}\n"
						sleep(0.5)
					}
					workflow.clearMessages
				end
			rescue
				puts "!! #{Time.now.localtime.to_s} #{$!}\n"
				ircSession.send_message(event.channel,$!)
			end
		end
	end
}
ircSession.connect
puts "** #{Time.now.localtime.to_s} shutdown\n"
